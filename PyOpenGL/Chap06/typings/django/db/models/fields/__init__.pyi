"""
This type stub file was generated by pyright.
"""

import collections.abc
import copy
import datetime
import decimal
import operator
import uuid
import warnings
from base64 import b64decode, b64encode
from functools import partialmethod, total_ordering
from django import forms
from django.apps import apps
from django.conf import settings
from django.core import checks, exceptions, validators
from django.db import connection, connections, router
from django.db.models.constants import LOOKUP_SEP
from django.db.models.query_utils import DeferredAttribute, RegisterLookupMixin
from django.utils import timezone
from django.utils.datastructures import DictWrapper
from django.utils.dateparse import parse_date, parse_datetime, parse_duration, parse_time
from django.utils.duration import duration_microseconds, duration_string
from django.utils.functional import Promise, cached_property
from django.utils.ipv6 import clean_ipv6_address
from django.utils.itercompat import is_iterable
from django.utils.text import capfirst
from django.utils.translation import gettext_lazy as _

class Empty:
    ...


class NOT_PROVIDED:
    ...


BLANK_CHOICE_DASH = ...
def return_None():
    ...

@total_ordering
class Field(RegisterLookupMixin):
    """Base class for all field types"""
    empty_strings_allowed = ...
    empty_values = ...
    creation_counter = ...
    auto_creation_counter = ...
    default_validators = ...
    default_error_messages = ...
    system_check_deprecated_details = ...
    system_check_removed_details = ...
    hidden = ...
    many_to_many = ...
    many_to_one = ...
    one_to_many = ...
    one_to_one = ...
    related_model = ...
    descriptor_class = DeferredAttribute
    description = ...
    def __init__(self, verbose_name=..., name=..., primary_key=..., max_length=..., unique=..., blank=..., null=..., db_index=..., rel=..., default=..., editable=..., serialize=..., unique_for_date=..., unique_for_month=..., unique_for_year=..., choices=..., help_text=..., db_column=..., db_tablespace=..., auto_created=..., validators=..., error_messages=...) -> None:
        ...
    
    def __str__(self) -> str:
        """
        Return "app_label.model_label.field_name" for fields attached to
        models.
        """
        ...
    
    def __repr__(self):
        """Display the module, class, and name of the field."""
        ...
    
    def check(self, **kwargs):
        ...
    
    def get_col(self, alias, output_field=...):
        ...
    
    @cached_property
    def cached_col(self):
        ...
    
    def select_format(self, compiler, sql, params):
        """
        Custom format for select clauses. For example, GIS columns need to be
        selected as AsText(table.col) on MySQL as the table.col data can't be
        used by Django.
        """
        ...
    
    def deconstruct(self):
        """
        Return enough information to recreate the field as a 4-tuple:

         * The name of the field on the model, if contribute_to_class() has
           been run.
         * The import path of the field, including the class:e.g.
           django.db.models.IntegerField This should be the most portable
           version, so less specific may be better.
         * A list of positional arguments.
         * A dict of keyword arguments.

        Note that the positional or keyword arguments must contain values of
        the following types (including inner values of collection types):

         * None, bool, str, int, float, complex, set, frozenset, list, tuple,
           dict
         * UUID
         * datetime.datetime (naive), datetime.date
         * top-level classes, top-level functions - will be referenced by their
           full import path
         * Storage instances - these have their own deconstruct() method

        This is because the values here must be serialized into a text format
        (possibly new Python code, possibly JSON) and these are the only types
        with encoding handlers defined.

        There's no need to return the exact way the field was instantiated this
        time, just ensure that the resulting field is the same - prefer keyword
        arguments over positional ones, and omit parameters with their default
        values.
        """
        ...
    
    def clone(self):
        """
        Uses deconstruct() to clone a new copy of this Field.
        Will not preserve any class attachments/attribute names.
        """
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __lt__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __deepcopy__(self, memodict):
        ...
    
    def __copy__(self):
        ...
    
    def __reduce__(self):
        """
        Pickling should return the model._meta.fields instance of the field,
        not a new copy of that field. So, use the app registry to load the
        model and then the field back.
        """
        ...
    
    def get_pk_value_on_save(self, instance):
        """
        Hook to generate new PK values on save. This method is called when
        saving instances with no primary key value set. If this method returns
        something else than None, then the returned value is used when saving
        the new instance.
        """
        ...
    
    def to_python(self, value):
        """
        Convert the input value into the expected Python data type, raising
        django.core.exceptions.ValidationError if the data can't be converted.
        Return the converted value. Subclasses should override this.
        """
        ...
    
    @cached_property
    def validators(self):
        """
        Some validators can't be created at field initialization time.
        This method provides a way to delay their creation until required.
        """
        ...
    
    def run_validators(self, value):
        ...
    
    def validate(self, value, model_instance):
        """
        Validate value and raise ValidationError if necessary. Subclasses
        should override this to provide validation logic.
        """
        ...
    
    def clean(self, value, model_instance):
        """
        Convert the value's type and run validation. Validation errors
        from to_python() and validate() are propagated. Return the correct
        value if no error is raised.
        """
        ...
    
    def db_type_parameters(self, connection):
        ...
    
    def db_check(self, connection):
        """
        Return the database column check constraint for this field, for the
        provided connection. Works the same way as db_type() for the case that
        get_internal_type() does not map to a preexisting model field.
        """
        ...
    
    def db_type(self, connection):
        """
        Return the database column data type for this field, for the provided
        connection.
        """
        ...
    
    def rel_db_type(self, connection):
        """
        Return the data type that a related field pointing to this field should
        use. For example, this method is called by ForeignKey and OneToOneField
        to determine its data type.
        """
        ...
    
    def cast_db_type(self, connection):
        """Return the data type to use in the Cast() function."""
        ...
    
    def db_parameters(self, connection):
        """
        Extension of db_type(), providing a range of different return values
        (type, checks). This will look at db_type(), allowing custom model
        fields to override it.
        """
        ...
    
    def db_type_suffix(self, connection):
        ...
    
    def get_db_converters(self, connection):
        ...
    
    @property
    def unique(self):
        ...
    
    @property
    def db_tablespace(self):
        ...
    
    @property
    def db_returning(self):
        """
        Private API intended only to be used by Django itself. Currently only
        the PostgreSQL backend supports returning multiple fields on a model.
        """
        ...
    
    def set_attributes_from_name(self, name):
        ...
    
    def contribute_to_class(self, cls, name, private_only=...):
        """
        Register the field with the model class it belongs to.

        If private_only is True, create a separate instance of this field
        for every subclass of cls, even if cls is not an abstract model.
        """
        ...
    
    def get_filter_kwargs_for_object(self, obj):
        """
        Return a dict that when passed as kwargs to self.model.filter(), would
        yield all instances having the same value for this field as obj has.
        """
        ...
    
    def get_attname(self):
        ...
    
    def get_attname_column(self):
        ...
    
    def get_internal_type(self):
        ...
    
    def pre_save(self, model_instance, add):
        """Return field's value just before saving."""
        ...
    
    def get_prep_value(self, value):
        """Perform preliminary non-db specific value checks and conversions."""
        ...
    
    def get_db_prep_value(self, value, connection, prepared=...):
        """
        Return field's value prepared for interacting with the database backend.

        Used by the default implementations of get_db_prep_save().
        """
        ...
    
    def get_db_prep_save(self, value, connection):
        """Return field's value prepared for saving into a database."""
        ...
    
    def has_default(self):
        """Return a boolean of whether this field has a default value."""
        ...
    
    def get_default(self):
        """Return the default value for this field."""
        ...
    
    def get_choices(self, include_blank=..., blank_choice=..., limit_choices_to=..., ordering=...):
        """
        Return choices with a default blank choices included, for use
        as <select> choices for this field.
        """
        ...
    
    def value_to_string(self, obj):
        """
        Return a string value of this field from the passed obj.
        This is used by the serialization framework.
        """
        ...
    
    flatchoices = ...
    def save_form_data(self, instance, data):
        ...
    
    def formfield(self, form_class=..., choices_form_class=..., **kwargs):
        """Return a django.forms.Field instance for this field."""
        ...
    
    def value_from_object(self, obj):
        """Return the value of this field in the given model instance."""
        ...
    


class BooleanField(Field):
    empty_strings_allowed = ...
    default_error_messages = ...
    description = ...
    def get_internal_type(self):
        ...
    
    def to_python(self, value):
        ...
    
    def get_prep_value(self, value):
        ...
    
    def formfield(self, **kwargs):
        ...
    


class CharField(Field):
    description = ...
    def __init__(self, *args, db_collation=..., **kwargs) -> None:
        ...
    
    def check(self, **kwargs):
        ...
    
    def cast_db_type(self, connection):
        ...
    
    def get_internal_type(self):
        ...
    
    def to_python(self, value):
        ...
    
    def get_prep_value(self, value):
        ...
    
    def formfield(self, **kwargs):
        ...
    
    def deconstruct(self):
        ...
    


class CommaSeparatedIntegerField(CharField):
    default_validators = ...
    description = ...
    system_check_removed_details = ...


class DateTimeCheckMixin:
    def check(self, **kwargs):
        ...
    


class DateField(DateTimeCheckMixin, Field):
    empty_strings_allowed = ...
    default_error_messages = ...
    description = ...
    def __init__(self, verbose_name=..., name=..., auto_now=..., auto_now_add=..., **kwargs) -> None:
        ...
    
    def deconstruct(self):
        ...
    
    def get_internal_type(self):
        ...
    
    def to_python(self, value):
        ...
    
    def pre_save(self, model_instance, add):
        ...
    
    def contribute_to_class(self, cls, name, **kwargs):
        ...
    
    def get_prep_value(self, value):
        ...
    
    def get_db_prep_value(self, value, connection, prepared=...):
        ...
    
    def value_to_string(self, obj):
        ...
    
    def formfield(self, **kwargs):
        ...
    


class DateTimeField(DateField):
    empty_strings_allowed = ...
    default_error_messages = ...
    description = ...
    def get_internal_type(self):
        ...
    
    def to_python(self, value):
        ...
    
    def pre_save(self, model_instance, add):
        ...
    
    def get_prep_value(self, value):
        ...
    
    def get_db_prep_value(self, value, connection, prepared=...):
        ...
    
    def value_to_string(self, obj):
        ...
    
    def formfield(self, **kwargs):
        ...
    


class DecimalField(Field):
    empty_strings_allowed = ...
    default_error_messages = ...
    description = ...
    def __init__(self, verbose_name=..., name=..., max_digits=..., decimal_places=..., **kwargs) -> None:
        ...
    
    def check(self, **kwargs):
        ...
    
    @cached_property
    def validators(self):
        ...
    
    @cached_property
    def context(self):
        ...
    
    def deconstruct(self):
        ...
    
    def get_internal_type(self):
        ...
    
    def to_python(self, value):
        ...
    
    def get_db_prep_save(self, value, connection):
        ...
    
    def get_prep_value(self, value):
        ...
    
    def formfield(self, **kwargs):
        ...
    


class DurationField(Field):
    """
    Store timedelta objects.

    Use interval on PostgreSQL, INTERVAL DAY TO SECOND on Oracle, and bigint
    of microseconds on other databases.
    """
    empty_strings_allowed = ...
    default_error_messages = ...
    description = ...
    def get_internal_type(self):
        ...
    
    def to_python(self, value):
        ...
    
    def get_db_prep_value(self, value, connection, prepared=...):
        ...
    
    def get_db_converters(self, connection):
        ...
    
    def value_to_string(self, obj):
        ...
    
    def formfield(self, **kwargs):
        ...
    


class EmailField(CharField):
    default_validators = ...
    description = ...
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def deconstruct(self):
        ...
    
    def formfield(self, **kwargs):
        ...
    


class FilePathField(Field):
    description = ...
    def __init__(self, verbose_name=..., name=..., path=..., match=..., recursive=..., allow_files=..., allow_folders=..., **kwargs) -> None:
        ...
    
    def check(self, **kwargs):
        ...
    
    def deconstruct(self):
        ...
    
    def get_prep_value(self, value):
        ...
    
    def formfield(self, **kwargs):
        ...
    
    def get_internal_type(self):
        ...
    


class FloatField(Field):
    empty_strings_allowed = ...
    default_error_messages = ...
    description = ...
    def get_prep_value(self, value):
        ...
    
    def get_internal_type(self):
        ...
    
    def to_python(self, value):
        ...
    
    def formfield(self, **kwargs):
        ...
    


class IntegerField(Field):
    empty_strings_allowed = ...
    default_error_messages = ...
    description = ...
    def check(self, **kwargs):
        ...
    
    @cached_property
    def validators(self):
        ...
    
    def get_prep_value(self, value):
        ...
    
    def get_internal_type(self):
        ...
    
    def to_python(self, value):
        ...
    
    def formfield(self, **kwargs):
        ...
    


class BigIntegerField(IntegerField):
    description = ...
    MAX_BIGINT = ...
    def get_internal_type(self):
        ...
    
    def formfield(self, **kwargs):
        ...
    


class SmallIntegerField(IntegerField):
    description = ...
    def get_internal_type(self):
        ...
    


class IPAddressField(Field):
    empty_strings_allowed = ...
    description = ...
    system_check_removed_details = ...
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def deconstruct(self):
        ...
    
    def get_prep_value(self, value):
        ...
    
    def get_internal_type(self):
        ...
    


class GenericIPAddressField(Field):
    empty_strings_allowed = ...
    description = ...
    default_error_messages = ...
    def __init__(self, verbose_name=..., name=..., protocol=..., unpack_ipv4=..., *args, **kwargs) -> None:
        ...
    
    def check(self, **kwargs):
        ...
    
    def deconstruct(self):
        ...
    
    def get_internal_type(self):
        ...
    
    def to_python(self, value):
        ...
    
    def get_db_prep_value(self, value, connection, prepared=...):
        ...
    
    def get_prep_value(self, value):
        ...
    
    def formfield(self, **kwargs):
        ...
    


class NullBooleanField(BooleanField):
    default_error_messages = ...
    description = ...
    system_check_deprecated_details = ...
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def deconstruct(self):
        ...
    
    def get_internal_type(self):
        ...
    


class PositiveIntegerRelDbTypeMixin:
    def __init_subclass__(cls, **kwargs):
        ...
    
    def rel_db_type(self, connection):
        """
        Return the data type that a related field pointing to this field should
        use. In most cases, a foreign key pointing to a positive integer
        primary key will have an integer column data type but some databases
        (e.g. MySQL) have an unsigned integer type. In that case
        (related_fields_match_type=True), the primary key should return its
        db_type.
        """
        ...
    


class PositiveBigIntegerField(PositiveIntegerRelDbTypeMixin, BigIntegerField):
    description = ...
    def get_internal_type(self):
        ...
    
    def formfield(self, **kwargs):
        ...
    


class PositiveIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField):
    description = ...
    def get_internal_type(self):
        ...
    
    def formfield(self, **kwargs):
        ...
    


class PositiveSmallIntegerField(PositiveIntegerRelDbTypeMixin, SmallIntegerField):
    description = ...
    def get_internal_type(self):
        ...
    
    def formfield(self, **kwargs):
        ...
    


class SlugField(CharField):
    default_validators = ...
    description = ...
    def __init__(self, *args, max_length=..., db_index=..., allow_unicode=..., **kwargs) -> None:
        ...
    
    def deconstruct(self):
        ...
    
    def get_internal_type(self):
        ...
    
    def formfield(self, **kwargs):
        ...
    


class TextField(Field):
    description = ...
    def __init__(self, *args, db_collation=..., **kwargs) -> None:
        ...
    
    def check(self, **kwargs):
        ...
    
    def get_internal_type(self):
        ...
    
    def to_python(self, value):
        ...
    
    def get_prep_value(self, value):
        ...
    
    def formfield(self, **kwargs):
        ...
    
    def deconstruct(self):
        ...
    


class TimeField(DateTimeCheckMixin, Field):
    empty_strings_allowed = ...
    default_error_messages = ...
    description = ...
    def __init__(self, verbose_name=..., name=..., auto_now=..., auto_now_add=..., **kwargs) -> None:
        ...
    
    def deconstruct(self):
        ...
    
    def get_internal_type(self):
        ...
    
    def to_python(self, value):
        ...
    
    def pre_save(self, model_instance, add):
        ...
    
    def get_prep_value(self, value):
        ...
    
    def get_db_prep_value(self, value, connection, prepared=...):
        ...
    
    def value_to_string(self, obj):
        ...
    
    def formfield(self, **kwargs):
        ...
    


class URLField(CharField):
    default_validators = ...
    description = ...
    def __init__(self, verbose_name=..., name=..., **kwargs) -> None:
        ...
    
    def deconstruct(self):
        ...
    
    def formfield(self, **kwargs):
        ...
    


class BinaryField(Field):
    description = ...
    empty_values = ...
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def check(self, **kwargs):
        ...
    
    def deconstruct(self):
        ...
    
    def get_internal_type(self):
        ...
    
    def get_placeholder(self, value, compiler, connection):
        ...
    
    def get_default(self):
        ...
    
    def get_db_prep_value(self, value, connection, prepared=...):
        ...
    
    def value_to_string(self, obj):
        """Binary data is serialized as base64"""
        ...
    
    def to_python(self, value):
        ...
    


class UUIDField(Field):
    default_error_messages = ...
    description = ...
    empty_strings_allowed = ...
    def __init__(self, verbose_name=..., **kwargs) -> None:
        ...
    
    def deconstruct(self):
        ...
    
    def get_internal_type(self):
        ...
    
    def get_prep_value(self, value):
        ...
    
    def get_db_prep_value(self, value, connection, prepared=...):
        ...
    
    def to_python(self, value):
        ...
    
    def formfield(self, **kwargs):
        ...
    


class AutoFieldMixin:
    db_returning = ...
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def check(self, **kwargs):
        ...
    
    def deconstruct(self):
        ...
    
    def validate(self, value, model_instance):
        ...
    
    def get_db_prep_value(self, value, connection, prepared=...):
        ...
    
    def contribute_to_class(self, cls, name, **kwargs):
        ...
    
    def formfield(self, **kwargs):
        ...
    


class AutoFieldMeta(type):
    """
    Metaclass to maintain backward inheritance compatibility for AutoField.

    It is intended that AutoFieldMixin become public API when it is possible to
    create a non-integer automatically-generated field using column defaults
    stored in the database.

    In many areas Django also relies on using isinstance() to check for an
    automatically-generated field as a subclass of AutoField. A new flag needs
    to be implemented on Field to be used instead.

    When these issues have been addressed, this metaclass could be used to
    deprecate inheritance from AutoField and use of isinstance() with AutoField
    for detecting automatically-generated fields.
    """
    def __instancecheck__(self, instance):
        ...
    
    def __subclasscheck__(self, subclass):
        ...
    


class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):
    def get_internal_type(self):
        ...
    
    def rel_db_type(self, connection):
        ...
    


class BigAutoField(AutoFieldMixin, BigIntegerField):
    def get_internal_type(self):
        ...
    
    def rel_db_type(self, connection):
        ...
    


class SmallAutoField(AutoFieldMixin, SmallIntegerField):
    def get_internal_type(self):
        ...
    
    def rel_db_type(self, connection):
        ...
    


