"""
This type stub file was generated by pyright.
"""

import sys
from typing import Any, Generic, List, Literal, Sequence, SupportsIndex, Tuple, Union, overload
from numpy import _ModeKind, _OrderCF, bool_, bytes_, complex_, float_, int_, integer, intp, matrix as _Matrix, ndarray, str_
from numpy.typing import ArrayLike, DTypeLike, NDArray, _ArrayLikeInt, _NestedSequence, _RecursiveSequence, _ShapeLike, _SupportsDType

"""
This type stub file was generated by pyright.
"""
if sys.version_info >= (3, 8):
    ...
else:
    ...
_T = ...
_DType = ...
_BoolType = ...
_TupType = ...
_ArrayType = ...
__all__: List[str]
@overload
def unravel_index(indices: Union[int, integer[Any]], shape: _ShapeLike, order: _OrderCF = ...) -> Tuple[intp, ...]:
    ...

@overload
def unravel_index(indices: _ArrayLikeInt, shape: _ShapeLike, order: _OrderCF = ...) -> Tuple[NDArray[intp], ...]:
    ...

@overload
def ravel_multi_index(multi_index: Sequence[Union[int, integer[Any]]], dims: _ShapeLike, mode: Union[_ModeKind, Tuple[_ModeKind, ...]] = ..., order: _OrderCF = ...) -> intp:
    ...

@overload
def ravel_multi_index(multi_index: Sequence[_ArrayLikeInt], dims: _ShapeLike, mode: Union[_ModeKind, Tuple[_ModeKind, ...]] = ..., order: _OrderCF = ...) -> NDArray[intp]:
    ...

@overload
def ix_(*args: _NestedSequence[_SupportsDType[_DType]]) -> Tuple[ndarray[Any, _DType], ...]:
    ...

@overload
def ix_(*args: _NestedSequence[str]) -> Tuple[NDArray[str_], ...]:
    ...

@overload
def ix_(*args: _NestedSequence[bytes]) -> Tuple[NDArray[bytes_], ...]:
    ...

@overload
def ix_(*args: _NestedSequence[bool]) -> Tuple[NDArray[bool_], ...]:
    ...

@overload
def ix_(*args: _NestedSequence[int]) -> Tuple[NDArray[int_], ...]:
    ...

@overload
def ix_(*args: _NestedSequence[float]) -> Tuple[NDArray[float_], ...]:
    ...

@overload
def ix_(*args: _NestedSequence[complex]) -> Tuple[NDArray[complex_], ...]:
    ...

@overload
def ix_(*args: _RecursiveSequence) -> Tuple[NDArray[Any], ...]:
    ...

class nd_grid(Generic[_BoolType]):
    sparse: _BoolType
    def __init__(self, sparse: _BoolType = ...) -> None:
        ...
    
    @overload
    def __getitem__(self: nd_grid[Literal[False]], key: Union[slice, Sequence[slice]]) -> NDArray[Any]:
        ...
    
    @overload
    def __getitem__(self: nd_grid[Literal[True]], key: Union[slice, Sequence[slice]]) -> List[NDArray[Any]]:
        ...
    


class MGridClass(nd_grid[Literal[False]]):
    def __init__(self) -> None:
        ...
    


mgrid: MGridClass
class OGridClass(nd_grid[Literal[True]]):
    def __init__(self) -> None:
        ...
    


ogrid: OGridClass
class AxisConcatenator:
    axis: int
    matrix: bool
    ndmin: int
    trans1d: int
    def __init__(self, axis: int = ..., matrix: bool = ..., ndmin: int = ..., trans1d: int = ...) -> None:
        ...
    
    @staticmethod
    @overload
    def concatenate(*a: ArrayLike, axis: SupportsIndex = ..., out: None = ...) -> NDArray[Any]:
        ...
    
    @staticmethod
    @overload
    def concatenate(*a: ArrayLike, axis: SupportsIndex = ..., out: _ArrayType = ...) -> _ArrayType:
        ...
    
    @staticmethod
    def makemat(data: ArrayLike, dtype: DTypeLike = ..., copy: bool = ...) -> _Matrix:
        ...
    
    def __getitem__(self, key: Any) -> Any:
        ...
    


class RClass(AxisConcatenator):
    axis: Literal[0]
    matrix: Literal[False]
    ndmin: Literal[1]
    trans1d: Literal[- 1]
    def __init__(self) -> None:
        ...
    


r_: RClass
class CClass(AxisConcatenator):
    axis: Literal[- 1]
    matrix: Literal[False]
    ndmin: Literal[2]
    trans1d: Literal[0]
    def __init__(self) -> None:
        ...
    


c_: CClass
class IndexExpression(Generic[_BoolType]):
    maketuple: _BoolType
    def __init__(self, maketuple: _BoolType) -> None:
        ...
    
    @overload
    def __getitem__(self, item: _TupType) -> _TupType:
        ...
    
    @overload
    def __getitem__(self: IndexExpression[Literal[True]], item: _T) -> Tuple[_T]:
        ...
    
    @overload
    def __getitem__(self: IndexExpression[Literal[False]], item: _T) -> _T:
        ...
    


index_exp: IndexExpression[Literal[True]]
s_: IndexExpression[Literal[False]]
def fill_diagonal(a: ndarray[Any, Any], val: Any, wrap: bool = ...) -> None:
    ...

def diag_indices(n: int, ndim: int = ...) -> Tuple[NDArray[int_], ...]:
    ...

def diag_indices_from(arr: ArrayLike) -> Tuple[NDArray[int_], ...]:
    ...

