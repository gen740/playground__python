import enum
from .exceptions import ConnectionClosed
from .frames import Frame
from .http11 import Request, Response
from .typing import LoggerLike
from _typeshed import Incomplete
from typing import Generator, List, Optional, Union

Event = Union[Request, Response, Frame]

class Side(enum.IntEnum):
    SERVER: Incomplete
    CLIENT: Incomplete

class State(enum.IntEnum):
    CONNECTING: Incomplete
    OPEN: Incomplete
    CLOSING: Incomplete
    CLOSED: Incomplete

SEND_EOF: bytes

class Connection:
    id: Incomplete
    logger: Incomplete
    debug: Incomplete
    side: Incomplete
    max_size: Incomplete
    cur_size: Incomplete
    expect_continuation_frame: bool
    origin: Incomplete
    extensions: Incomplete
    subprotocol: Incomplete
    close_rcvd: Incomplete
    close_sent: Incomplete
    close_rcvd_then_sent: Incomplete
    handshake_exc: Incomplete
    eof_sent: bool
    reader: Incomplete
    events: Incomplete
    writes: Incomplete
    parser: Incomplete
    parser_exc: Incomplete
    def __init__(self, side: Side, state: State = ..., max_size: Optional[int] = ..., logger: Optional[LoggerLike] = ...) -> None: ...
    @property
    def state(self) -> State: ...
    @state.setter
    def state(self, state: State) -> None: ...
    @property
    def close_code(self) -> Optional[int]: ...
    @property
    def close_reason(self) -> Optional[str]: ...
    @property
    def close_exc(self) -> ConnectionClosed: ...
    def receive_data(self, data: bytes) -> None: ...
    def receive_eof(self) -> None: ...
    def send_continuation(self, data: bytes, fin: bool) -> None: ...
    def send_text(self, data: bytes, fin: bool = ...) -> None: ...
    def send_binary(self, data: bytes, fin: bool = ...) -> None: ...
    def send_close(self, code: Optional[int] = ..., reason: str = ...) -> None: ...
    def send_ping(self, data: bytes) -> None: ...
    def send_pong(self, data: bytes) -> None: ...
    def fail(self, code: int, reason: str = ...) -> None: ...
    def events_received(self) -> List[Event]: ...
    def data_to_send(self) -> List[bytes]: ...
    def close_expected(self) -> bool: ...
    def parse(self) -> Generator[None, None, None]: ...
    def discard(self) -> Generator[None, None, None]: ...
    def recv_frame(self, frame: Frame) -> None: ...
    def send_frame(self, frame: Frame) -> None: ...
    def send_eof(self) -> None: ...
