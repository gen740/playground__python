import asyncio
from ..exceptions import ConnectionClosed
from ..frames import Close
from ..typing import Data, LoggerLike
from .framing import Frame
from _typeshed import Incomplete
from typing import Any, AsyncIterable, AsyncIterator, Awaitable, Iterable, Optional, Union

class WebSocketCommonProtocol(asyncio.Protocol):
    is_client: bool
    side: str
    ping_interval: Incomplete
    ping_timeout: Incomplete
    close_timeout: Incomplete
    max_size: Incomplete
    max_queue: Incomplete
    read_limit: Incomplete
    write_limit: Incomplete
    id: Incomplete
    logger: Incomplete
    debug: Incomplete
    loop: Incomplete
    legacy_recv: Incomplete
    reader: Incomplete
    state: Incomplete
    path: Incomplete
    request_headers: Incomplete
    response_headers: Incomplete
    extensions: Incomplete
    subprotocol: Incomplete
    close_rcvd: Incomplete
    close_sent: Incomplete
    close_rcvd_then_sent: Incomplete
    connection_lost_waiter: Incomplete
    messages: Incomplete
    pings: Incomplete
    transfer_data_task: Incomplete
    transfer_data_exc: Incomplete
    keepalive_ping_task: Incomplete
    close_connection_task: Incomplete
    def __init__(self, *, logger: Optional[LoggerLike] = ..., ping_interval: Optional[float] = ..., ping_timeout: Optional[float] = ..., close_timeout: Optional[float] = ..., max_size: Optional[int] = ..., max_queue: Optional[int] = ..., read_limit: int = ..., write_limit: int = ..., host: Optional[str] = ..., port: Optional[int] = ..., secure: Optional[bool] = ..., legacy_recv: bool = ..., loop: Optional[asyncio.AbstractEventLoop] = ..., timeout: Optional[float] = ...) -> None: ...
    def connection_open(self) -> None: ...
    @property
    def host(self) -> Optional[str]: ...
    @property
    def port(self) -> Optional[int]: ...
    @property
    def secure(self) -> Optional[bool]: ...
    @property
    def local_address(self) -> Any: ...
    @property
    def remote_address(self) -> Any: ...
    @property
    def open(self) -> bool: ...
    @property
    def closed(self) -> bool: ...
    @property
    def close_code(self) -> Optional[int]: ...
    @property
    def close_reason(self) -> Optional[str]: ...
    async def __aiter__(self) -> AsyncIterator[Data]: ...
    async def recv(self) -> Data: ...
    async def send(self, message: Union[Data, Iterable[Data], AsyncIterable[Data]]) -> None: ...
    async def close(self, code: int = ..., reason: str = ...) -> None: ...
    async def wait_closed(self) -> None: ...
    async def ping(self, data: Optional[Data] = ...) -> Awaitable[None]: ...
    async def pong(self, data: Data = ...) -> None: ...
    def connection_closed_exc(self) -> ConnectionClosed: ...
    async def ensure_open(self) -> None: ...
    async def transfer_data(self) -> None: ...
    async def read_message(self) -> Optional[Data]: ...
    async def read_data_frame(self, max_size: Optional[int]) -> Optional[Frame]: ...
    async def read_frame(self, max_size: Optional[int]) -> Frame: ...
    def write_frame_sync(self, fin: bool, opcode: int, data: bytes) -> None: ...
    async def drain(self) -> None: ...
    async def write_frame(self, fin: bool, opcode: int, data: bytes, *, _state: int = ...) -> None: ...
    async def write_close_frame(self, close: Close, data: Optional[bytes] = ...) -> None: ...
    async def keepalive_ping(self) -> None: ...
    async def close_connection(self) -> None: ...
    async def close_transport(self) -> None: ...
    async def wait_for_connection_lost(self) -> bool: ...
    def fail_connection(self, code: int = ..., reason: str = ...) -> None: ...
    def abort_pings(self) -> None: ...
    transport: Incomplete
    def connection_made(self, transport: asyncio.BaseTransport) -> None: ...
    def connection_lost(self, exc: Optional[Exception]) -> None: ...
    def pause_writing(self) -> None: ...
    def resume_writing(self) -> None: ...
    def data_received(self, data: bytes) -> None: ...
    def eof_received(self) -> None: ...

def broadcast(websockets: Iterable[WebSocketCommonProtocol], message: Data) -> None: ...
