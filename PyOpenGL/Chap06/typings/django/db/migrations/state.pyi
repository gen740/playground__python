"""
This type stub file was generated by pyright.
"""

from contextlib import contextmanager
from django.apps import AppConfig
from django.apps.registry import Apps
from django.utils.functional import cached_property

def get_related_models_tuples(model):
    """
    Return a list of typical (app_label, model_name) tuples for all related
    models for the given model.
    """
    ...

def get_related_models_recursive(model):
    """
    Return all models that have a direct or indirect relationship
    to the given model.

    Relationships are either defined by explicit relational fields, like
    ForeignKey, ManyToManyField or OneToOneField, or by inheriting from another
    model (a superclass is related to its subclasses, but not vice versa). Note,
    however, that a model inheriting from a concrete model is also related to
    its superclass through the implicit *_ptr OneToOneField on the subclass.
    """
    ...

class ProjectState:
    """
    Represent the entire project's overall state. This is the item that is
    passed around - do it here rather than at the app level so that cross-app
    FKs/etc. resolve properly.
    """
    def __init__(self, models=..., real_apps=...) -> None:
        ...
    
    def add_model(self, model_state):
        ...
    
    def remove_model(self, app_label, model_name):
        ...
    
    def reload_model(self, app_label, model_name, delay=...):
        ...
    
    def reload_models(self, models, delay=...):
        ...
    
    def clone(self):
        """Return an exact copy of this ProjectState."""
        ...
    
    def clear_delayed_apps_cache(self):
        ...
    
    @cached_property
    def apps(self):
        ...
    
    @property
    def concrete_apps(self):
        ...
    
    @classmethod
    def from_apps(cls, apps):
        """Take an Apps and return a ProjectState matching it."""
        ...
    
    def __eq__(self, other) -> bool:
        ...
    


class AppConfigStub(AppConfig):
    """Stub of an AppConfig. Only provides a label and a dict of models."""
    def __init__(self, label) -> None:
        ...
    
    def import_models(self):
        ...
    


class StateApps(Apps):
    """
    Subclass of the global Apps registry class to better handle dynamic model
    additions and removals.
    """
    def __init__(self, real_apps, models, ignore_swappable=...) -> None:
        ...
    
    @contextmanager
    def bulk_update(self):
        ...
    
    def render_multiple(self, model_states):
        ...
    
    def clone(self):
        """Return a clone of this registry."""
        ...
    
    def register_model(self, app_label, model):
        ...
    
    def unregister_model(self, app_label, model_name):
        ...
    


class ModelState:
    """
    Represent a Django Model. Don't use the actual Model class as it's not
    designed to have its options changed - instead, mutate this one and then
    render it into a Model as required.

    Note that while you are allowed to mutate .fields, you are not allowed
    to mutate the Field instances inside there themselves - you must instead
    assign new ones, as these are not detached during a clone.
    """
    def __init__(self, app_label, name, fields, options=..., bases=..., managers=...) -> None:
        ...
    
    @cached_property
    def name_lower(self):
        ...
    
    @classmethod
    def from_model(cls, model, exclude_rels=...):
        """Given a model, return a ModelState representing it."""
        ...
    
    def construct_managers(self):
        """Deep-clone the managers using deconstruction."""
        ...
    
    def clone(self):
        """Return an exact copy of this ModelState."""
        ...
    
    def render(self, apps):
        """Create a Model object from our current state into the given apps."""
        ...
    
    def get_index_by_name(self, name):
        ...
    
    def get_constraint_by_name(self, name):
        ...
    
    def __repr__(self):
        ...
    
    def __eq__(self, other) -> bool:
        ...
    


