"""
This type stub file was generated by pyright.
"""

import sys
from typing import List, TYPE_CHECKING
from ._nbit import _NBitByte, _NBitDouble, _NBitHalf, _NBitInt, _NBitIntC, _NBitIntP, _NBitLongDouble, _NBitLongLong, _NBitShort, _NBitSingle
from ._char_codes import _BoolCodes, _ByteCodes, _BytesCodes, _CDoubleCodes, _CLongDoubleCodes, _CSingleCodes, _Complex128Codes, _Complex64Codes, _DT64Codes, _DoubleCodes, _Float16Codes, _Float32Codes, _Float64Codes, _HalfCodes, _Int16Codes, _Int32Codes, _Int64Codes, _Int8Codes, _IntCCodes, _IntCodes, _IntPCodes, _LongDoubleCodes, _LongLongCodes, _ObjectCodes, _ShortCodes, _SingleCodes, _StrCodes, _TD64Codes, _UByteCodes, _UInt16Codes, _UInt32Codes, _UInt64Codes, _UInt8Codes, _UIntCCodes, _UIntCodes, _UIntPCodes, _ULongLongCodes, _UShortCodes, _VoidCodes
from ._scalars import _BoolLike_co, _CharLike_co, _ComplexLike_co, _FloatLike_co, _IntLike_co, _NumberLike_co, _ScalarLike_co, _TD64Like_co, _UIntLike_co, _VoidLike_co
from ._shape import _Shape, _ShapeLike
from ._dtype_like import DTypeLike as DTypeLike, _DTypeLikeBool, _DTypeLikeBytes, _DTypeLikeComplex, _DTypeLikeComplex_co, _DTypeLikeDT64, _DTypeLikeFloat, _DTypeLikeInt, _DTypeLikeObject, _DTypeLikeStr, _DTypeLikeTD64, _DTypeLikeUInt, _DTypeLikeVoid, _SupportsDType, _VoidDTypeLike
from ._array_like import ArrayLike as ArrayLike, _ArrayLike, _ArrayLikeBool_co, _ArrayLikeBytes_co, _ArrayLikeComplex_co, _ArrayLikeDT64_co, _ArrayLikeFloat_co, _ArrayLikeInt, _ArrayLikeInt_co, _ArrayLikeNumber_co, _ArrayLikeObject_co, _ArrayLikeStr_co, _ArrayLikeTD64_co, _ArrayLikeUInt_co, _ArrayLikeVoid_co, _NestedSequence, _RecursiveSequence, _SupportsArray
from ._generic_alias import NDArray as NDArray, _GenericAlias
from ._ufunc import _GUFunc_Nin2_Nout1, _UFunc_Nin1_Nout1, _UFunc_Nin1_Nout2, _UFunc_Nin2_Nout1, _UFunc_Nin2_Nout2
from ._add_docstring import _docstrings
from numpy._pytesttester import PytestTester

"""
This type stub file was generated by pyright.
"""
if TYPE_CHECKING:
    ...
else:
    ...
if not TYPE_CHECKING:
    ...
else:
    __all__: List[str]
    ...
@final
class NBitBase:
    """
    An object representing `numpy.number` precision during static type checking.

    Used exclusively for the purpose static type checking, `NBitBase`
    represents the base of a hierarchical set of subclasses.
    Each subsequent subclass is herein used for representing a lower level
    of precision, *e.g.* ``64Bit > 32Bit > 16Bit``.

    Examples
    --------
    Below is a typical usage example: `NBitBase` is herein used for annotating a
    function that takes a float and integer of arbitrary precision as arguments
    and returns a new float of whichever precision is largest
    (*e.g.* ``np.float16 + np.int64 -> np.float64``).

    .. code-block:: python

        >>> from __future__ import annotations
        >>> from typing import TypeVar, Union, TYPE_CHECKING
        >>> import numpy as np
        >>> import numpy.typing as npt

        >>> T1 = TypeVar("T1", bound=npt.NBitBase)
        >>> T2 = TypeVar("T2", bound=npt.NBitBase)

        >>> def add(a: np.floating[T1], b: np.integer[T2]) -> np.floating[Union[T1, T2]]:
        ...     return a + b

        >>> a = np.float16()
        >>> b = np.int64()
        >>> out = add(a, b)

        >>> if TYPE_CHECKING:
        ...     reveal_locals()
        ...     # note: Revealed local types are:
        ...     # note:     a: numpy.floating[numpy.typing._16Bit*]
        ...     # note:     b: numpy.signedinteger[numpy.typing._64Bit*]
        ...     # note:     out: numpy.floating[numpy.typing._64Bit*]

    """
    def __init_subclass__(cls) -> None:
        ...
    


class _256Bit(NBitBase):
    ...


class _128Bit(_256Bit):
    ...


class _96Bit(_128Bit):
    ...


class _80Bit(_96Bit):
    ...


class _64Bit(_80Bit):
    ...


class _32Bit(_64Bit):
    ...


class _16Bit(_32Bit):
    ...


class _8Bit(_16Bit):
    ...


if TYPE_CHECKING:
    ...
else:
    ...
if __doc__ is not None:
    ...
test = ...
