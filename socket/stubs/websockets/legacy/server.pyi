import asyncio
import http
import socket
from ..datastructures import Headers, HeadersLike
from ..extensions import Extension, ServerExtensionFactory
from ..typing import LoggerLike, Origin, Subprotocol
from .protocol import WebSocketCommonProtocol
from _typeshed import Incomplete
from types import TracebackType
from typing import Any, Awaitable, Callable, Generator, Iterable, List, Optional, Sequence, Tuple, Type, Union

HeadersLikeOrCallable = Union[HeadersLike, Callable[[str, Headers], HeadersLike]]
HTTPResponse = Tuple[http.HTTPStatus, HeadersLike, bytes]

class WebSocketServerProtocol(WebSocketCommonProtocol):
    is_client: bool
    side: str
    ws_handler: Incomplete
    ws_server: Incomplete
    origins: Incomplete
    available_extensions: Incomplete
    available_subprotocols: Incomplete
    extra_headers: Incomplete
    def __init__(self, ws_handler: Union[Callable[[WebSocketServerProtocol], Awaitable[Any]], Callable[[WebSocketServerProtocol, str], Awaitable[Any]]], ws_server: WebSocketServer, *, logger: Optional[LoggerLike] = ..., origins: Optional[Sequence[Optional[Origin]]] = ..., extensions: Optional[Sequence[ServerExtensionFactory]] = ..., subprotocols: Optional[Sequence[Subprotocol]] = ..., extra_headers: Optional[HeadersLikeOrCallable] = ..., process_request: Optional[Callable[[str, Headers], Awaitable[Optional[HTTPResponse]]]] = ..., select_subprotocol: Optional[Callable[[Sequence[Subprotocol], Sequence[Subprotocol]], Subprotocol]] = ..., **kwargs: Any) -> None: ...
    handler_task: Incomplete
    def connection_made(self, transport: asyncio.BaseTransport) -> None: ...
    async def handler(self) -> None: ...
    path: Incomplete
    request_headers: Incomplete
    async def read_http_request(self) -> Tuple[str, Headers]: ...
    response_headers: Incomplete
    def write_http_response(self, status: http.HTTPStatus, headers: Headers, body: Optional[bytes] = ...) -> None: ...
    async def process_request(self, path: str, request_headers: Headers) -> Optional[HTTPResponse]: ...
    @staticmethod
    def process_origin(headers: Headers, origins: Optional[Sequence[Optional[Origin]]] = ...) -> Optional[Origin]: ...
    @staticmethod
    def process_extensions(headers: Headers, available_extensions: Optional[Sequence[ServerExtensionFactory]]) -> Tuple[Optional[str], List[Extension]]: ...
    def process_subprotocol(self, headers: Headers, available_subprotocols: Optional[Sequence[Subprotocol]]) -> Optional[Subprotocol]: ...
    def select_subprotocol(self, client_subprotocols: Sequence[Subprotocol], server_subprotocols: Sequence[Subprotocol]) -> Optional[Subprotocol]: ...
    origin: Incomplete
    async def handshake(self, origins: Optional[Sequence[Optional[Origin]]] = ..., available_extensions: Optional[Sequence[ServerExtensionFactory]] = ..., available_subprotocols: Optional[Sequence[Subprotocol]] = ..., extra_headers: Optional[HeadersLikeOrCallable] = ...) -> str: ...

class WebSocketServer:
    logger: Incomplete
    websockets: Incomplete
    close_task: Incomplete
    closed_waiter: Incomplete
    def __init__(self, logger: Optional[LoggerLike] = ...) -> None: ...
    server: Incomplete
    def wrap(self, server: asyncio.base_events.Server) -> None: ...
    def register(self, protocol: WebSocketServerProtocol) -> None: ...
    def unregister(self, protocol: WebSocketServerProtocol) -> None: ...
    def close(self) -> None: ...
    async def wait_closed(self) -> None: ...
    def get_loop(self) -> asyncio.AbstractEventLoop: ...
    def is_serving(self) -> bool: ...
    async def start_serving(self) -> None: ...
    async def serve_forever(self) -> None: ...
    @property
    def sockets(self) -> Iterable[socket.socket]: ...
    async def __aenter__(self) -> WebSocketServer: ...
    async def __aexit__(self, exc_type: Optional[Type[BaseException]], exc_value: Optional[BaseException], traceback: Optional[TracebackType]) -> None: ...

class Serve:
    ws_server: Incomplete
    def __init__(self, ws_handler: Union[Callable[[WebSocketServerProtocol], Awaitable[Any]], Callable[[WebSocketServerProtocol, str], Awaitable[Any]]], host: Optional[Union[str, Sequence[str]]] = ..., port: Optional[int] = ..., *, create_protocol: Optional[Callable[[Any], WebSocketServerProtocol]] = ..., logger: Optional[LoggerLike] = ..., compression: Optional[str] = ..., origins: Optional[Sequence[Optional[Origin]]] = ..., extensions: Optional[Sequence[ServerExtensionFactory]] = ..., subprotocols: Optional[Sequence[Subprotocol]] = ..., extra_headers: Optional[HeadersLikeOrCallable] = ..., process_request: Optional[Callable[[str, Headers], Awaitable[Optional[HTTPResponse]]]] = ..., select_subprotocol: Optional[Callable[[Sequence[Subprotocol], Sequence[Subprotocol]], Subprotocol]] = ..., ping_interval: Optional[float] = ..., ping_timeout: Optional[float] = ..., close_timeout: Optional[float] = ..., max_size: Optional[int] = ..., max_queue: Optional[int] = ..., read_limit: int = ..., write_limit: int = ..., **kwargs: Any) -> None: ...
    async def __aenter__(self) -> WebSocketServer: ...
    async def __aexit__(self, exc_type: Optional[Type[BaseException]], exc_value: Optional[BaseException], traceback: Optional[TracebackType]) -> None: ...
    def __await__(self) -> Generator[Any, None, WebSocketServer]: ...
    async def __await_impl__(self) -> WebSocketServer: ...
    __iter__: Incomplete
serve = Serve

def unix_serve(ws_handler: Union[Callable[[WebSocketServerProtocol], Awaitable[Any]], Callable[[WebSocketServerProtocol, str], Awaitable[Any]]], path: Optional[str] = ..., **kwargs: Any) -> Serve: ...
